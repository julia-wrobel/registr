---
title: "Registering Incomplete Curves"
author: "Alexander Bauer"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Registering Incomplete Curves}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
h1 { /* Header 1 */
  font-size: 26px;
}
h2 { /* Header 2 */
  font-size: 20px;
}
h3 { /* Header 3 */
  font-size: 16px;
}
</style>


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 5
)
```

This vignette outlines the functionalities of the `registr` package with
regard to incomplete curves.

```{r load_libraries, echo = FALSE}
library(registr)
library(ggplot2)
theme_set(theme_minimal() + theme(plot.title = element_text(hjust = 0.5)))
```

# Introduction

Incomplete curves arise in many applications. Incompleteness refers to functional
data where (some) curves were not observed until the very end of the common
domain.
Such a data structure is e.g. observed in the presence of drop-out in panel studies.
Exemplarily, we showcase the following functionalities on data from the Berkeley
Growth Study (see `?growth_incomplete`) where we artificially simulated that
children dropped out of the study at some point in time:

```{r Berkeley data}
dat = registr::growth_incomplete

# sort the data by the amount of incompleteness
ids    = levels(dat$id)
dat$id = factor(dat$id, levels = ids[order(sapply(ids, function(curve_id) {
	sum(!is.na(dat$value[dat$id == curve_id]))
}))])

# spaghetti plot
ggplot(dat, aes(x = index, y = value, group = id)) +
	geom_line(alpha = 0.2) +
	xlab("t* [observed]") + ylab("Derivative") +
	ggtitle("First derivative of growth curves")
```


```{r Berkeley data 2, fig.height = 4}
# lasagna plot
ggplot(dat, aes(x = index, y = id, col = value)) + 
	geom_line(lwd = 2.5) +
	scale_color_continuous("Derivative", high = "midnightblue", low = "lightskyblue1") +
  xlab("t* [observed]") + ylab("curve") +
  ggtitle("First derivative of growth curves") +
	theme(panel.grid  = element_blank(),
				axis.text.y = element_blank())
```


# Incomplete curve methodology

We adapt the registration methodology outlined in Wrobel et al. (2019) to
handle incomplete curves. Since each curve potentially has an individual range
of its observed time domain, the spline basis for estimating a curve's warping
function is defined individually for each curve, based on a given number of
basis functions.

It often is a quite strict assumption in incomplete data
settings that all warping functions end on the diagonal, i.e. that the individual,
observed part of the whole time domain is not (to some extent) distorted.
Therefore, the `registr` package gives the additional option to estimate
warping functions without the constraint that the endpoint lies on the diagonal.

On the other end, if we fully remove the constraint for the endpoints
to lie on the diagonal, this can lead to very extreme and unrealistic distortions
of the time domain. This problem is further accompanied by the fact that
the assessment of some given warping to be realistic or unrealistic can heavily
vary between different applications.
As of this reason, our method includes a penalization parameter $\lambda$ that
has to be set manually to specify which kinds of distortions are deemed realistic
in the application at hand.

Mathematically speaking, we add a penalization term to the likelihood $\ell(i)$ 
for curve $i$:
$$
\begin{aligned}
\ell_{pen}(i) &= \ell(i) - \lambda \cdot pen(i), \\
\text{with} \ \ \ 
pen(i) &= \left( \hat{h}^{-1}_i(t^*_{max,i}) - t^*_{max,i} \right)^2,
\end{aligned}
$$
where $t^*_{max,i}$ is the maximum of the observed time domain of curve $i$ and
$\hat{h}^{-1}_i(t^*_{max,i})$ the inverse warping function evaluated at this
maximum.

The higher the penalization parameter $\lambda$, the more the endpoint
of the warping function is forced towards an identity warp, i.e. the diagonal line.
Given a specific application, $\lambda$ should be chosen s.t.
unrealistic distortions of the time domain are prevented.
To do so, the user has to run the registration approach multiple times with
different $\lambda$'s to find an optimal value.


# Application on incomplete growth data

By default, both functions `register_fpca` and `registr` include the argument
`incompleteness = NULL` to constrain all warping functions to start and end on the diagonal.

```{r application 1}
reg1 = registr(Y = dat, family = "gaussian")

ggplot(reg1$Y, aes(x = tstar, y = index, group = id)) + 
	geom_line(alpha = 0.2) +
	xlab("t* [observed]") + ylab("t [registered]") +
	ggtitle("Estimated warping functions")
```

```{r application 1 lasagna, fig.height = 4}
ggplot(reg1$Y, aes(x = index, y = id, col = value)) + 
	geom_line(lwd = 2.5) +
	scale_color_continuous("Derivative", high = "midnightblue", low = "lightskyblue1") +
  xlab("t [registered]") + ylab("curve") +
  ggtitle("Registered curves") +
	theme(panel.grid  = element_blank(),
				axis.text.y = element_blank())
```

The assumption can be dropped by setting `incompleteness` to some other value than NULL and
some nonnegative value for the penalization parameter `lambda_inc`.
The higher `lambda_inc` is chosen, the more all warping functions are forced
to start/end close to the diagonal.

### Small `lambda_inc`

```{r application 2}
reg2 = registr(Y = dat, family = "gaussian",
							 incompleteness = "trailing", lambda_inc = 1)

ggplot(reg2$Y, aes(x = tstar, y = index, group = id)) + 
	geom_line(alpha = 0.2) +
	xlab("t* [observed]") + ylab("t [registered]") +
	ggtitle("Estimated warping functions")
```

```{r application 2 lasagna, fig.height = 4}
ggplot(reg2$Y, aes(x = index, y = id, col = value)) + 
	geom_line(lwd = 2.5) +
	scale_color_continuous("Derivative", high = "midnightblue", low = "lightskyblue1") +
  xlab("t [registered]") + ylab("curve") +
  ggtitle("Registered curves") +
	theme(panel.grid  = element_blank(),
				axis.text.y = element_blank())
```

### Large `lambda_inc`

```{r application 3}
reg3 = registr(Y = dat, family = "gaussian",
							 incompleteness = "trailing", lambda_inc = 10)

ggplot(reg3$Y, aes(x = tstar, y = index, group = id)) + 
	geom_line(alpha = 0.2) +
	xlab("t* [observed]") + ylab("t [registered]") +
	ggtitle("Estimated warping functions")
```

```{r application 3 lasagna, fig.height = 4}
ggplot(reg3$Y, aes(x = index, y = id, col = value)) + 
	geom_line(lwd = 2.5) +
	scale_color_continuous("Derivative", high = "midnightblue", low = "lightskyblue1") +
  xlab("t [registered]") + ylab("curve") +
  ggtitle("Registered curves") +
	theme(panel.grid  = element_blank(),
				axis.text.y = element_blank())
```


# Constraint matrices for the optimization

Warping functions are estimated using the function `constrOptim()`.
For the estimation step of curve $i$ it uses linear inequality constraints of the form
$$
\boldsymbol{u}_i \cdot \boldsymbol{\beta}_i - \boldsymbol{c}_i \geq \boldsymbol{0},
$$
where $\boldsymbol{\beta}_i$ is the parameter vector and matrix
$\boldsymbol{u}_i$ and vector $\boldsymbol{c}_i$ define the constraints.

For the estimation of a warping function the parameter vector is constrained
s.t. the resulting warping function is monotone and does not exceed the overall
time domain $[t_{min},t_{max}]$.

In the following the constraint matrices are listed for different settings 
of (in)completeness and assuming a parameter vector of length $p$:
$$
\boldsymbol{\beta}_i =
\left( \begin{array}{c}
\beta_{i1} \\ \beta_{i2} \\ \vdots \\ \beta_{ip}
\end{array} \right) \in \mathbb{R}_{p \times 1}
$$

**Note:**  
All following constraint matrices refer to the estimation of nonparametric inverse
warping functions with `warping = "nonparametric"`.


## Complete curve setting

When all curves were observed completely -- i.e. the underlying processes of
interest were all observed from the beginning until the end -- warping functions
can typically be assumed to start and end on the diagonal, since each process is
completely observed in its observation interval $[t^*_{min,i},t^*_{max,i}] \subset [t_{min},t_{max}]$.

Assuming that both the starting point and the endpoint lie on the diagonal,
we set $\beta_{i1} = t^*_{min,i}$ and $\beta_{ip} = t^*_{max,i}$ and only perform
the estimation for
$$
\left( \begin{array}{c}
\beta_{i2} \\ \beta_{i3} \\ \vdots \\ \beta_{i(p-1)}
\end{array} \right) \in \mathbb{R}_{(p-2) \times 1}
$$

This results in the following constraint matrices, that allow a mapping from the
observed domain $[t^*_{min,i},t^*_{max,i}]$ to the domain itself $[t^*_{min,i},t^*_{max,i}] \subset [t_{min},t_{max}]$:
$$
\begin{aligned}
\boldsymbol{u}_i &=
\left( \begin{array}{cccccccc}
1 & 0 & 0 & 0 & \ldots & 0 & 0 & 0 \\
-1 & 1 & 0 & 0 & \ldots & 0 & 0 & 0 \\
0 & -1 & 1 & 0 & \ldots & 0 & 0 & 0 \\
\vdots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots \\
0 & 0 & 0 & 0 & \ldots & 0 & -1 & 1 \\
0 & 0 & 0 & 0 & \ldots & 0 & 0 & -1
\end{array} \right) \in \mathbb{R}_{(p-1) \times (p-2)} \\
\boldsymbol{c}_i &=
\left( \begin{array}{c}
t^*_{min,i} \\ 0 \\ 0 \\ \vdots \\ 0 \\ -1 \cdot t^*_{max,i}
\end{array} \right) \in \mathbb{R}_{(p-1) \times 1}
\end{aligned}
$$

## Leading incompleteness only

In the case of *leading incompleteness* -- i.e. the underlying processes of interest
were all observed until their very end but not necessarily starting from their beginning -- warping functions
can typically be assumed to end on the diagonal, s.t. one assumes
$\beta_{ip} = t^*_{max,i}$ to let the warping functions end at the last observed
time point $t^*_{max,i}$. The estimation is then performed for the remaining
parameter vector
$$
\left( \begin{array}{c}
\beta_{i1} \\ \beta_{i3} \\ \vdots \\ \beta_{i(p-1)}
\end{array} \right) \in \mathbb{R}_{(p-1) \times 1}
$$

This results in the following constraint matrices, that allow a mapping from the
observed domain $[t^*_{min,i},t^*_{max,i}]$ to the domain $[t_{min},t^*_{max,i}]$:
$$
\begin{aligned}
\boldsymbol{u}_i &=
\left( \begin{array}{cccccccc}
1 & 0 & 0 & 0 & \ldots & 0 & 0 & 0 \\
-1 & 1 & 0 & 0 & \ldots & 0 & 0 & 0 \\
0 & -1 & 1 & 0 & \ldots & 0 & 0 & 0 \\
\vdots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots \\
0 & 0 & 0 & 0 & \ldots & 0 & -1 & 1 \\
0 & 0 & 0 & 0 & \ldots & 0 & 0 & -1
\end{array} \right) \in \mathbb{R}_{p \times (p-1)} \\
\boldsymbol{c}_i &=
\left( \begin{array}{c}
t_{min} \\ 0 \\ 0 \\ \vdots \\ 0 \\ -1 \cdot t^*_{max,i}
\end{array} \right) \in \mathbb{R}_{p \times 1}
\end{aligned}
$$

## Trailing incompleteness only

In the case of *trailing incompleteness* -- i.e. the underlying processes of interest
were all observed from the beginning but not necessarily until their very end -- warping functions
can typically be assumed to start on the diagonal, s.t. one assumes
$\beta_{i1} = t^*_{min,i}$ to let the warping functions start at the first observed
time point $t^*_{min,i}$. The estimation is then performed for the remaining
parameter vector
$$
\left( \begin{array}{c}
\beta_{i2} \\ \beta_{i3} \\ \vdots \\ \beta_{ip}
\end{array} \right) \in \mathbb{R}_{(p-1) \times 1}
$$

This results in the following constraint matrices, that allow a mapping from the
observed domain $[t^*_{min,i},t^*_{max,i}]$ to the domain $[t^*_{min,i},t_{max}]$:
$$
\begin{aligned}
\boldsymbol{u}_i &\text{  identical to the version for leading incompleteness} \\
\boldsymbol{c}_i &=
\left( \begin{array}{c}
t^*_{min,i} \\ 0 \\ 0 \\ \vdots \\ 0 \\ -1 \cdot t_{max}
\end{array} \right) \in \mathbb{R}_{p \times 1}
\end{aligned}
$$

## Leading and trailing incompleteness

In the case of both leading and trailing incompleteness -- i.e. the underlying
processes of interest were neither necessarily observed from their very beginnings nor to their
very ends -- warping functions can typically only be assumed to map the
observed domains $[t^*_{min,i},t^*_{max,i}]$ to the overall domain
$[t_{min},t_{max}]$.

This results in the following constraint matrices:
$$
\begin{aligned}
\boldsymbol{u}_i &=
\left( \begin{array}{cccccccc}
1 & 0 & 0 & 0 & \ldots & 0 & 0 & 0 \\
-1 & 1 & 0 & 0 & \ldots & 0 & 0 & 0 \\
0 & -1 & 1 & 0 & \ldots & 0 & 0 & 0 \\
\vdots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots & \ddots \\
0 & 0 & 0 & 0 & \ldots & 0 & -1 & 1 \\
0 & 0 & 0 & 0 & \ldots & 0 & 0 & -1
\end{array} \right) \in \mathbb{R}_{(p+1) \times p} \\
\boldsymbol{c}_i &=
\left( \begin{array}{c}
t_{min} \\ 0 \\ 0 \\ \vdots \\ 0 \\ -1 \cdot t_{max}
\end{array} \right) \in \mathbb{R}_{(p+1) \times 1}
\end{aligned}
$$


# Help files

Documentation for individual functions gives more information on their arguments and return objects, and can be pulled up via the following:

- `?register_fpca`
- `?registr`
